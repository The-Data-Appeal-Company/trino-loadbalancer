package lb

import (
	"github.com/The-Data-Appeal-Company/trino-loadbalancer/pkg/api/trino"
	"github.com/The-Data-Appeal-Company/trino-loadbalancer/pkg/common/logging"
	"github.com/The-Data-Appeal-Company/trino-loadbalancer/pkg/common/models"
	"github.com/The-Data-Appeal-Company/trino-loadbalancer/pkg/discovery"
	"github.com/The-Data-Appeal-Company/trino-loadbalancer/pkg/proxy/healthcheck"
	"github.com/The-Data-Appeal-Company/trino-loadbalancer/pkg/proxy/routing"
	"github.com/The-Data-Appeal-Company/trino-loadbalancer/pkg/proxy/session"
	"github.com/stretchr/testify/require"
	"net/http"
	"net/http/httptest"
	"time"

	"testing"
)

var proxyConfig = ProxyConf{
	SyncDelay: 1 * time.Hour,
}

func TestProxyRouting(t *testing.T) {

	fakeCoord0 := httptest.NewServer(http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		writer.WriteHeader(http.StatusOK)
	}))
	defer fakeCoord0.Close()

	sessStore := session.NewMemoryStorage()
	hc := healthcheck.NoOp()
	stats := trino.Noop()

	router := routing.New(routing.NewUserAwareRouter(routing.UserAwareRoutingConf{}), routing.RandomRouter{})

	logger := logging.Noop()
	pool := NewPool(PoolConfigTest(), sessStore, hc, stats, logger)

	err := pool.Add(models.Coordinator{
		Name:    "test",
		URL:     mustUrl(fakeCoord0.URL),
		Enabled: true,
	})
	require.NoError(t, err)

	proxy := NewProxy(proxyConfig, pool, NoOpSync{}, sessStore, router, RequestReWriters(), logger)

	srv := httptest.NewServer(http.HandlerFunc(proxy.Handle))
	defer srv.Close()

	res, err := http.Post(srv.URL, "application/json", nil)
	require.NoError(t, err)
	require.Equal(t, res.StatusCode, http.StatusOK)

}

func TestProxyRoutingMultiCoordinator(t *testing.T) {

	fakeCoord0 := httptest.NewServer(http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		writer.WriteHeader(http.StatusOK)
	}))
	defer fakeCoord0.Close()

	fakeCoord1 := httptest.NewServer(http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		writer.WriteHeader(http.StatusOK)
	}))
	defer fakeCoord1.Close()

	sessStore := session.NewMemoryStorage()
	hc := healthcheck.NoOp()
	stats := trino.Noop()

	router := routing.New(routing.NewUserAwareRouter(routing.UserAwareRoutingConf{}), routing.RoundRobin())

	logger := logging.Noop()
	pool := NewPool(PoolConfigTest(), sessStore, hc, stats, logger)

	err := pool.Add(models.Coordinator{
		Name:    "cluster-0",
		URL:     mustUrl(fakeCoord0.URL),
		Enabled: true,
	})
	require.NoError(t, err)

	err = pool.Add(models.Coordinator{
		Name:    "cluster-1",
		URL:     mustUrl(fakeCoord1.URL),
		Enabled: true,
	})
	require.NoError(t, err)

	proxy := NewProxy(proxyConfig, pool, NoOpSync{}, sessStore, router, RequestReWriters(), logger)

	srv := httptest.NewServer(http.HandlerFunc(proxy.Handle))
	defer srv.Close()

	for i := 0; i < 10; i++ {
		res, err := http.Post(srv.URL, "application/json", nil)
		require.NoError(t, err)
		require.Equal(t, res.StatusCode, http.StatusOK)
	}
}

func TestProxyWithUnhealthyBackend(t *testing.T) {

	sessStore := session.NewMemoryStorage()
	hc := healthcheck.NewTrinoQueryHealth()
	stats := trino.Noop()

	router := routing.New(routing.NewUserAwareRouter(routing.UserAwareRoutingConf{}), routing.RandomRouter{})

	logger := logging.Noop()

	pool := NewPool(PoolConfigTest(), sessStore, hc, stats, logger)
	err := pool.Add(models.Coordinator{
		Name:    "test",
		URL:     mustUrl("http://trino.local:1231"),
		Enabled: true,
	})
	require.NoError(t, err)

	proxy := NewProxy(proxyConfig, pool, NoOpSync{}, sessStore, router, RequestReWriters(), logger)

	srv := httptest.NewServer(http.HandlerFunc(proxy.Handle))
	defer srv.Close()

	res, err := http.Post(srv.URL, "application/json", nil)
	require.NoError(t, err)
	require.Equal(t, res.StatusCode, http.StatusServiceUnavailable)

}

func TestProxyWithHealthyUnreachableBackend(t *testing.T) {

	sessStore := session.NewMemoryStorage()
	hc := healthcheck.NoOp()
	stats := trino.Noop()

	router := routing.New(routing.NewUserAwareRouter(routing.UserAwareRoutingConf{}), routing.RandomRouter{})

	logger := logging.Noop()
	pool := NewPool(PoolConfigTest(), sessStore, hc, stats, logger)

	err := pool.Add(models.Coordinator{
		Name:    "test",
		URL:     mustUrl("http://trino.local:1231"),
		Enabled: true,
	})
	require.NoError(t, err)

	proxy := NewProxy(proxyConfig, pool, NoOpSync{}, sessStore, router, RequestReWriters(), logger)

	srv := httptest.NewServer(http.HandlerFunc(proxy.Handle))
	defer srv.Close()

	res, err := http.Post(srv.URL, "application/json", nil)
	require.NoError(t, err)
	require.Equal(t, res.StatusCode, http.StatusBadGateway)

}

func TestProxyWithNoBackends(t *testing.T) {

	stateStore := discovery.NewMemoryStorage()
	sessStore := session.NewMemoryStorage()
	hc := healthcheck.NewTrinoQueryHealth()
	stats := trino.Noop()

	router := routing.New(routing.NewUserAwareRouter(routing.UserAwareRoutingConf{}), routing.RandomRouter{})

	logger := logging.Noop()

	pool := NewPool(PoolConfigTest(), sessStore, hc, stats, logger)
	poolStateSync := NewPoolStateSync(stateStore, logger)

	proxy := NewProxy(proxyConfig, pool, poolStateSync, sessStore, router, RequestReWriters(), logger)

	srv := httptest.NewServer(http.HandlerFunc(proxy.Handle))
	defer srv.Close()

	res, err := http.Post(srv.URL, "application/json", nil)
	require.NoError(t, err)
	require.Equal(t, res.StatusCode, http.StatusServiceUnavailable)

}

func TestProxyHealthEndpoint(t *testing.T) {

	stateStore := discovery.NewMemoryStorage()
	sessStore := session.NewMemoryStorage()
	hc := healthcheck.NewTrinoQueryHealth()
	stats := trino.Noop()

	router := routing.New(routing.NewUserAwareRouter(routing.UserAwareRoutingConf{}), routing.RandomRouter{})

	logger := logging.Noop()

	pool := NewPool(PoolConfigTest(), sessStore, hc, stats, logger)
	poolStateSync := NewPoolStateSync(stateStore, logger)

	proxy := NewProxy(proxyConfig, pool, poolStateSync, sessStore, router, RequestReWriters(), logger)

	srv := httptest.NewServer(proxy.Router())
	defer srv.Close()

	res, err := http.Get(srv.URL + "/health")
	require.NoError(t, err)
	require.Equal(t, res.StatusCode, http.StatusOK)

}
